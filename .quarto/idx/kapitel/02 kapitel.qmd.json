{"title":"Grundlegende Datentypen","markdown":{"yaml":{"title":"Grundlegende Datentypen"},"headingText":"Integer (Ganze Zahlen)","containsRefs":false,"markdown":"\n\nZahlen sind nur einer von vielen grundlegenden Datentypen, auf die Sie in Python stoßen werden, insbesondere wenn Sie Datenanalysen durchführen. Ein fundiertes Verständnis dieser grundlegenden Datentypen ist entscheidend, um mit Daten in Python zu arbeiten.\n\n\nIntegers (kurz \"ints\"; Ganze Zahlen), sind numerische Werte ohne Dezimalstellen ([siehe Wiki](https://www.wikiwand.com/de/Ganze_Zahl)). Jede positive oder negative Zahl (oder 0) ohne Dezimalstelle ist ein Integer in Python. Integers haben eine unbegrenzte Genauigkeit, was bedeutet, dass sie exakt sind. Mit der Funktion `type()` kann der Typ eines Python-Objekts überprüft werden:\n\n```{python}\n#| class.output: custom-output\ntype(12)\n```\n\nWie wir oben sehen können, ist der Typ von 12 ein \"int\". Sie können auch die Funktion `isinstance()` verwenden, um zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist:\n\n```{python}\nisinstance(12, int) # Überprüfen, ob 12 vom Typ \"int\" ist\n```\n\nDer Code bestätigt, dass 12 ein Integer (`int`) ist.\n\nInteger unterstützen alle grundlegenden mathematischen Operationen, die wir das letzte Mal behandelt haben. Wenn eine mathematische Operation mit Integer zu einem Ergebnis führt, das kein Integer ist (ein Dezimalwert), wird das Ergebnis zu einem Float:\n\n```{python}\n1/3\n```\n\n```{python}\ntype(1/3)\n```\n\n## Floats (Gleitkommazahlen)\n\nFloats (floating point number; Gleitkommazahlen) sind Zahlen mit Dezimalstellen ([siehe Wiki](https://www.wikiwand.com/de/Gleitkommazahl)). Im Gegensatz zu Integer haben Floats keine unbegrenzte Genauigkeit, da irrationale Dezimalzahlen unendlich lang sind und daher nicht im Speicher abgelegt werden können. Stattdessen wird der Wert langer Dezimalstellen vom Computer angenähert, sodass es bei langen Floats zu kleinen Rundungsfehlern kommen kann. Dieser Fehler ist so gering, dass er normalerweise nicht von Bedeutung ist, kann sich jedoch in bestimmten Fällen bei vielen wiederholten Berechnungen summieren.\n\nJede Zahl in Python mit einem Dezimalpunkt ist ein Float, auch wenn nach dem Dezimalpunkt keine von null verschiedenen Zahlen stehen:\n\n```{python}\ntype(1.0)\n```\n\n```{python}\nisinstance(0.33333, float)\n```\n\nDie in der letzten Lektion gelernten Rechenoperationen funktionieren sowohl bei Floats als auch bei Ints. Werden sowohl Floats als auch Ints im selben mathematischen Ausdruck verwendet, ist das Ergebnis ein Float:\n\n```{python}\n5 + 1.0 # Int + Float = Float\n```\n\nEin Float kann mit der Funktion `int()` in ein Integer umgewandelt werden:\n\n```{python}\nint(6.0)\n```\n\nMit der Funktion `float()` kann ein Integer in einen Float umgewandelt werden:\n\n```{python}\nfloat(6)\n```\n\nFloats können auch einige spezielle Werte annehmen: `Inf`, `-Inf` und `NaN`. `Inf` und `-Inf` stehen für Unendlichkeit und negative Unendlichkeit, und `NaN` steht für \"not a number\" und wird manchmal als Platzhalter für fehlende oder fehlerhafte numerische Werte verwendet.\n\n```{python}\ntype(float(\"Inf\"))\n```\n\n```{python}\ntype(float(\"NaN\"))\n```\n\nAnmerkung: Python enthält einen dritten, seltenen numerischen Datentyp \"complex\", der zur Speicherung von komplexen Zahlen verwendet wird.\n\n## Booleans\n\nBooleans (\"bools\") sind Wahr/Falsch-Werte, die aus logischen Aussagen resultieren ([siehe Wiki](https://www.wikiwand.com/de/Boolean)). In Python beginnen booleans mit einem Großbuchstaben, sodass `True` und `False` als bools erkannt werden, \"true\" und \"false\" jedoch nicht. Ein Beispiel für booleans wurde bereits gesehen, als die Funktion isinstance() oben verwendet wurde.\n\n```{python}\ntype(True)\n```\n\n```{python}\nisinstance(False, bool)  # Überprüfung, ob False vom Typ bool ist\n```\n\nBoolesche Werte können mit logischen Ausdrücken erzeugt werden. Python unterstützt alle standardmäßigen logischen Operatoren, die man erwarten würde:\n\n```{python}\n20 > 10 # > für größer als\n```\n\n```{python}\n20 < 5 # < für kleiner als\n```\n\n```{python}\n20 >= 20 # >= und <= für größer oder gleich und kleiner oder gleich\n```\n\n```{python}\n10 == 10 # Verwendung von == (zwei aufeinanderfolgende Gleichheitszeichen), um auf Gleichheit zu überprüfen\n```\n\n```{python}\n40 == 40.0  # Äquivalente ints und floats gelten als gleich\n```\n\n```{python}\n1 != 2 # != um auf Ungleichheit zu überprüfen; \"nicht gleich\"\n```\n\n```{python}\nnot False # Das Schlüsselwort \"not\" für die Negation verwenden\n```\n\n```{python}\n(2 > 1) and (10 > 11) # \"and\" für logisches Und verwenden\n```\n\n```{python}\n(2 > 1) or (10 > 11) # \"or\" für logisches Oder verwenden\n```\n\nÄhnlich wie bei mathematischen Ausdrücken haben logische Ausdrücke eine festgelegte Reihenfolge der Operationen. In einer logischen Aussage werden Vergleiche wie `>`, `<` und `==` zuerst ausgeführt, gefolgt von `not`, dann `and` und schließlich `or` ([siehe Details](https://docs.python.org/3/reference/expressions.html#operator-precedence)).\n\nKlammern werden verwendet, um die gewünschte Reihenfolge der Operationen zu erzwingen.\n\n```{python}\n2 > 1 or 10 < 8 and not True\n```\n\n```{python}\n((2 > 1) or (10 < 8)) and (not True)\n```\n\nZahlen können mit der Funktion `bool()` in boolesche Werte umgewandelt werden. Alle Zahlen außer 0 werden zu True konvertiert:\n\n```{python}\nbool(1)\n```\n\n```{python}\nbool(0)\n```\n\n## Strings\n\nTextdaten in Python werden als String oder `str` bezeichnet. Um einen String zu erstellen, umgibt man den Text mit einfachen oder doppelten Anführungszeichen:\n\n```{python}\ntype(\"cat\")\n```\n\n```{python}\ntype('1')\n```\n\nZwei Anführungszeichen direkt nebeneinander (wie `''` oder `\"\"`) ohne etwas dazwischen werden als der leere String bezeichnet. Der leere String stellt oft einen fehlenden Textwert dar.\n\nWährend numerische Daten und logische Daten im Allgemeinen gut handhabbar sind, können Textdaten sehr unordentlich und schwer zu bearbeiten sein. Das Säubern von Textdaten ist oft einer der mühsamsten Schritte bei der Vorbereitung von echten Datensätzen für die Analyse. In zukünftigen Lektionen wird erneut auf Strings und Funktionen eingegangen, um beim Säubern von Textdaten zu helfen.\n\n## None\n\nIn Python stellt `None` einen speziellen Datentyp dar, der häufig verwendet wird, um einen fehlenden Wert zu repräsentieren. Beispielsweise wird, wenn eine Funktion definiert wird, die nichts zurückgibt (keinen Ergebniswert liefert), standardmäßig `None` zurückgegeben.\n\n```{python}\ntype(None)\n```\n\n```{python}\n# Definieren einer Funktion, die den Eingabewert mittels 'print()' anzeigt, jedoch keinen Wert zurückgibt:\n\ndef my_function(x):\n    print(x)\n    \nmy_function(\"hello\") == None  # The output of my_function equals None\n```\n\n","srcMarkdownNoYaml":"\n\nZahlen sind nur einer von vielen grundlegenden Datentypen, auf die Sie in Python stoßen werden, insbesondere wenn Sie Datenanalysen durchführen. Ein fundiertes Verständnis dieser grundlegenden Datentypen ist entscheidend, um mit Daten in Python zu arbeiten.\n\n## Integer (Ganze Zahlen)\n\nIntegers (kurz \"ints\"; Ganze Zahlen), sind numerische Werte ohne Dezimalstellen ([siehe Wiki](https://www.wikiwand.com/de/Ganze_Zahl)). Jede positive oder negative Zahl (oder 0) ohne Dezimalstelle ist ein Integer in Python. Integers haben eine unbegrenzte Genauigkeit, was bedeutet, dass sie exakt sind. Mit der Funktion `type()` kann der Typ eines Python-Objekts überprüft werden:\n\n```{python}\n#| class.output: custom-output\ntype(12)\n```\n\nWie wir oben sehen können, ist der Typ von 12 ein \"int\". Sie können auch die Funktion `isinstance()` verwenden, um zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist:\n\n```{python}\nisinstance(12, int) # Überprüfen, ob 12 vom Typ \"int\" ist\n```\n\nDer Code bestätigt, dass 12 ein Integer (`int`) ist.\n\nInteger unterstützen alle grundlegenden mathematischen Operationen, die wir das letzte Mal behandelt haben. Wenn eine mathematische Operation mit Integer zu einem Ergebnis führt, das kein Integer ist (ein Dezimalwert), wird das Ergebnis zu einem Float:\n\n```{python}\n1/3\n```\n\n```{python}\ntype(1/3)\n```\n\n## Floats (Gleitkommazahlen)\n\nFloats (floating point number; Gleitkommazahlen) sind Zahlen mit Dezimalstellen ([siehe Wiki](https://www.wikiwand.com/de/Gleitkommazahl)). Im Gegensatz zu Integer haben Floats keine unbegrenzte Genauigkeit, da irrationale Dezimalzahlen unendlich lang sind und daher nicht im Speicher abgelegt werden können. Stattdessen wird der Wert langer Dezimalstellen vom Computer angenähert, sodass es bei langen Floats zu kleinen Rundungsfehlern kommen kann. Dieser Fehler ist so gering, dass er normalerweise nicht von Bedeutung ist, kann sich jedoch in bestimmten Fällen bei vielen wiederholten Berechnungen summieren.\n\nJede Zahl in Python mit einem Dezimalpunkt ist ein Float, auch wenn nach dem Dezimalpunkt keine von null verschiedenen Zahlen stehen:\n\n```{python}\ntype(1.0)\n```\n\n```{python}\nisinstance(0.33333, float)\n```\n\nDie in der letzten Lektion gelernten Rechenoperationen funktionieren sowohl bei Floats als auch bei Ints. Werden sowohl Floats als auch Ints im selben mathematischen Ausdruck verwendet, ist das Ergebnis ein Float:\n\n```{python}\n5 + 1.0 # Int + Float = Float\n```\n\nEin Float kann mit der Funktion `int()` in ein Integer umgewandelt werden:\n\n```{python}\nint(6.0)\n```\n\nMit der Funktion `float()` kann ein Integer in einen Float umgewandelt werden:\n\n```{python}\nfloat(6)\n```\n\nFloats können auch einige spezielle Werte annehmen: `Inf`, `-Inf` und `NaN`. `Inf` und `-Inf` stehen für Unendlichkeit und negative Unendlichkeit, und `NaN` steht für \"not a number\" und wird manchmal als Platzhalter für fehlende oder fehlerhafte numerische Werte verwendet.\n\n```{python}\ntype(float(\"Inf\"))\n```\n\n```{python}\ntype(float(\"NaN\"))\n```\n\nAnmerkung: Python enthält einen dritten, seltenen numerischen Datentyp \"complex\", der zur Speicherung von komplexen Zahlen verwendet wird.\n\n## Booleans\n\nBooleans (\"bools\") sind Wahr/Falsch-Werte, die aus logischen Aussagen resultieren ([siehe Wiki](https://www.wikiwand.com/de/Boolean)). In Python beginnen booleans mit einem Großbuchstaben, sodass `True` und `False` als bools erkannt werden, \"true\" und \"false\" jedoch nicht. Ein Beispiel für booleans wurde bereits gesehen, als die Funktion isinstance() oben verwendet wurde.\n\n```{python}\ntype(True)\n```\n\n```{python}\nisinstance(False, bool)  # Überprüfung, ob False vom Typ bool ist\n```\n\nBoolesche Werte können mit logischen Ausdrücken erzeugt werden. Python unterstützt alle standardmäßigen logischen Operatoren, die man erwarten würde:\n\n```{python}\n20 > 10 # > für größer als\n```\n\n```{python}\n20 < 5 # < für kleiner als\n```\n\n```{python}\n20 >= 20 # >= und <= für größer oder gleich und kleiner oder gleich\n```\n\n```{python}\n10 == 10 # Verwendung von == (zwei aufeinanderfolgende Gleichheitszeichen), um auf Gleichheit zu überprüfen\n```\n\n```{python}\n40 == 40.0  # Äquivalente ints und floats gelten als gleich\n```\n\n```{python}\n1 != 2 # != um auf Ungleichheit zu überprüfen; \"nicht gleich\"\n```\n\n```{python}\nnot False # Das Schlüsselwort \"not\" für die Negation verwenden\n```\n\n```{python}\n(2 > 1) and (10 > 11) # \"and\" für logisches Und verwenden\n```\n\n```{python}\n(2 > 1) or (10 > 11) # \"or\" für logisches Oder verwenden\n```\n\nÄhnlich wie bei mathematischen Ausdrücken haben logische Ausdrücke eine festgelegte Reihenfolge der Operationen. In einer logischen Aussage werden Vergleiche wie `>`, `<` und `==` zuerst ausgeführt, gefolgt von `not`, dann `and` und schließlich `or` ([siehe Details](https://docs.python.org/3/reference/expressions.html#operator-precedence)).\n\nKlammern werden verwendet, um die gewünschte Reihenfolge der Operationen zu erzwingen.\n\n```{python}\n2 > 1 or 10 < 8 and not True\n```\n\n```{python}\n((2 > 1) or (10 < 8)) and (not True)\n```\n\nZahlen können mit der Funktion `bool()` in boolesche Werte umgewandelt werden. Alle Zahlen außer 0 werden zu True konvertiert:\n\n```{python}\nbool(1)\n```\n\n```{python}\nbool(0)\n```\n\n## Strings\n\nTextdaten in Python werden als String oder `str` bezeichnet. Um einen String zu erstellen, umgibt man den Text mit einfachen oder doppelten Anführungszeichen:\n\n```{python}\ntype(\"cat\")\n```\n\n```{python}\ntype('1')\n```\n\nZwei Anführungszeichen direkt nebeneinander (wie `''` oder `\"\"`) ohne etwas dazwischen werden als der leere String bezeichnet. Der leere String stellt oft einen fehlenden Textwert dar.\n\nWährend numerische Daten und logische Daten im Allgemeinen gut handhabbar sind, können Textdaten sehr unordentlich und schwer zu bearbeiten sein. Das Säubern von Textdaten ist oft einer der mühsamsten Schritte bei der Vorbereitung von echten Datensätzen für die Analyse. In zukünftigen Lektionen wird erneut auf Strings und Funktionen eingegangen, um beim Säubern von Textdaten zu helfen.\n\n## None\n\nIn Python stellt `None` einen speziellen Datentyp dar, der häufig verwendet wird, um einen fehlenden Wert zu repräsentieren. Beispielsweise wird, wenn eine Funktion definiert wird, die nichts zurückgibt (keinen Ergebniswert liefert), standardmäßig `None` zurückgegeben.\n\n```{python}\ntype(None)\n```\n\n```{python}\n# Definieren einer Funktion, die den Eingabewert mittels 'print()' anzeigt, jedoch keinen Wert zurückgibt:\n\ndef my_function(x):\n    print(x)\n    \nmy_function(\"hello\") == None  # The output of my_function equals None\n```\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"retina","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"engine":"jupyter"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"output-file":"02 kapitel.html"},"language":{"toc-title-document":"Inhaltsverzeichnis","toc-title-website":"Auf dieser Seite","related-formats-title":"Andere Formate","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Quelle","section-title-abstract":"Zusammenfassung","section-title-appendices":"Anhang","section-title-footnotes":"Fußnoten","section-title-references":"Literatur","section-title-reuse":"Wiederverwendung","section-title-copyright":"Urheberrechte","section-title-citation":"Zitat","appendix-attribution-cite-as":"Bitte zitieren Sie diese Arbeit als:","appendix-attribution-bibtex":"Mit BibTeX zitieren:","title-block-author-single":"Autor:in","title-block-author-plural":"Autor:innen","title-block-affiliation-single":"Zugehörigkeit","title-block-affiliation-plural":"Zugehörigkeiten","title-block-published":"Veröffentlichungsdatum","title-block-modified":"Geändert","callout-tip-title":"Tipp","callout-note-title":"Hinweis","callout-warning-title":"Warnung","callout-important-title":"Wichtig","callout-caution-title":"Vorsicht","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Gesamten Code zeigen","code-tools-hide-all-code":"Gesamten Code verbergen","code-tools-view-source":"Quellcode anzeigen","code-tools-source-code":"Quellcode","code-line":"Zeile","code-lines":"Zeilen","copy-button-tooltip":"In die Zwischenablage kopieren","copy-button-tooltip-success":"Kopiert","repo-action-links-edit":"Seite editieren","repo-action-links-source":"Quellcode anzeigen","repo-action-links-issue":"Problem melden","back-to-top":"Zurück nach oben","search-no-results-text":"Keine Treffer","search-matching-documents-text":"Treffer","search-copy-link-title":"Link in die Suche kopieren","search-hide-matches-text":"Zusätzliche Treffer verbergen","search-more-match-text":"weitere Treffer in diesem Dokument","search-more-matches-text":"weitere Treffer in diesem Dokument","search-clear-button-title":"Zurücksetzen","search-detached-cancel-button-title":"Abbrechen","search-submit-button-title":"Abschicken","search-label":"Suchen","toggle-section":"Abschnitt umschalten","toggle-sidebar":"Seitenleiste umschalten","toggle-dark-mode":"Dunkelmodus umschalten","toggle-reader-mode":"Lesemodus umschalten","toggle-navigation":"Navigation umschalten","crossref-fig-title":"Abbildung","crossref-tbl-title":"Tabelle","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Korollar","crossref-prp-title":"Aussage","crossref-cnj-title":"Annahme","crossref-def-title":"Definition","crossref-exm-title":"Beispiel","crossref-exr-title":"Übungsaufgabe","crossref-ch-prefix":"Kapitel","crossref-apx-prefix":"Anhang","crossref-sec-prefix":"Kapitel","crossref-eq-prefix":"Gleichung","crossref-lof-title":"Abbildungsverzeichnis","crossref-lot-title":"Tabellenverzeichnis","crossref-lol-title":"Listingverzeichnis","environment-proof-title":"Beweis","environment-remark-title":"Anmerkung","environment-solution-title":"Lösung","listing-page-order-by":"Sortieren nach","listing-page-order-by-default":"Voreinstellung","listing-page-order-by-date-asc":"Datum (aufsteigend)","listing-page-order-by-date-desc":"Neueste","listing-page-order-by-number-desc":"Absteigend","listing-page-order-by-number-asc":"Aufsteigend","listing-page-field-date":"Datum","listing-page-field-title":"Titel","listing-page-field-description":"Beschreibung","listing-page-field-author":"Autor:in","listing-page-field-filename":"Dateiname","listing-page-field-filemodified":"Geändert","listing-page-field-subtitle":"Untertitel","listing-page-field-readingtime":"Lesezeit","listing-page-field-categories":"Kategorien","listing-page-minutes-compact":"{0} min","listing-page-category-all":"alle","listing-page-no-matches":"Keine Treffer"},"metadata":{"lang":"de","fig-responsive":true,"quarto-version":"1.3.433","jupyter":"python3","author":[{"name":{"given":"Paul","family":"Schmidt","literal":"Paul Schmidt"},"orcid":"0000-0003-1528-2082","affiliations":[{"name":"BioMath GmbH","city":"Hamburg","country":"Germany","url":"https://www.biomath.de/"},{"name":"& Freelancer","url":"https://schmidtpaul.github.io/"}]}],"author-title":"Autor","abstract-title":"Zusammenfassung","date":"last-modified","published-title":"Zuletzt aktualisiert","citation":true,"_quarto-vars":{"author":"Andrew Heiss","instructor":{"name":"Dr. Paul Schmidt","name_no_title":"Paul Schmidt","email":"paul.schmidt@biomath.de","url":"https://schmidtpaul.github.io/"},"company":{"name":"BioMath GmbH","url":"www.biomath.de"}},"anchor-sections":true,"code-summary":"Click to show/hide code","code-copy":true,"citations-hover":true,"footnotes-hover":true,"theme":"../theme.scss","title":"Grundlegende Datentypen"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}