{
  "hash": "3723770aaf38076ab48597655658f46d",
  "result": {
    "markdown": "---\ntitle: Grundlegende Datentypen\n---\n\nZahlen sind nur einer von vielen grundlegenden Datentypen, auf die Sie in Python stoßen werden, insbesondere wenn Sie Datenanalysen durchführen. Ein fundiertes Verständnis dieser grundlegenden Datentypen ist entscheidend, um mit Daten in Python zu arbeiten.\n\n## Integer (Ganze Zahlen)\n\nIntegers (kurz \"ints\"; Ganze Zahlen), sind numerische Werte ohne Dezimalstellen ([siehe Wiki](https://www.wikiwand.com/de/Ganze_Zahl)). Jede positive oder negative Zahl (oder 0) ohne Dezimalstelle ist ein Integer in Python. Integers haben eine unbegrenzte Genauigkeit, was bedeutet, dass sie exakt sind. Mit der Funktion `type()` kann der Typ eines Python-Objekts überprüft werden:\n\n::: {.cell class.output='custom-output' execution_count=1}\n``` {.python .cell-code}\ntype(12)\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\nint\n```\n:::\n:::\n\n\nWie wir oben sehen können, ist der Typ von 12 ein \"int\". Sie können auch die Funktion `isinstance()` verwenden, um zu überprüfen, ob ein Objekt eine Instanz eines bestimmten Typs ist:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nisinstance(12, int) # Überprüfen, ob 12 vom Typ \"int\" ist\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\nTrue\n```\n:::\n:::\n\n\nDer Code bestätigt, dass 12 ein Integer (`int`) ist.\n\nInteger unterstützen alle grundlegenden mathematischen Operationen, die wir das letzte Mal behandelt haben. Wenn eine mathematische Operation mit Integer zu einem Ergebnis führt, das kein Integer ist (ein Dezimalwert), wird das Ergebnis zu einem Float:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n1/3\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n0.3333333333333333\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ntype(1/3)\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\nfloat\n```\n:::\n:::\n\n\n## Floats (Gleitkommazahlen)\n\nFloats (floating point number; Gleitkommazahlen) sind Zahlen mit Dezimalstellen ([siehe Wiki](https://www.wikiwand.com/de/Gleitkommazahl)). Im Gegensatz zu Integer haben Floats keine unbegrenzte Genauigkeit, da irrationale Dezimalzahlen unendlich lang sind und daher nicht im Speicher abgelegt werden können. Stattdessen wird der Wert langer Dezimalstellen vom Computer angenähert, sodass es bei langen Floats zu kleinen Rundungsfehlern kommen kann. Dieser Fehler ist so gering, dass er normalerweise nicht von Bedeutung ist, kann sich jedoch in bestimmten Fällen bei vielen wiederholten Berechnungen summieren.\n\nJede Zahl in Python mit einem Dezimalpunkt ist ein Float, auch wenn nach dem Dezimalpunkt keine von null verschiedenen Zahlen stehen:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ntype(1.0)\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\nfloat\n```\n:::\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nisinstance(0.33333, float)\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\nTrue\n```\n:::\n:::\n\n\nDie in der letzten Lektion gelernten Rechenoperationen funktionieren sowohl bei Floats als auch bei Ints. Werden sowohl Floats als auch Ints im selben mathematischen Ausdruck verwendet, ist das Ergebnis ein Float:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n5 + 1.0 # Int + Float = Float\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\n6.0\n```\n:::\n:::\n\n\nEin Float kann mit der Funktion `int()` in ein Integer umgewandelt werden:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nint(6.0)\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\n6\n```\n:::\n:::\n\n\nMit der Funktion `float()` kann ein Integer in einen Float umgewandelt werden:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nfloat(6)\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\n6.0\n```\n:::\n:::\n\n\nFloats können auch einige spezielle Werte annehmen: `Inf`, `-Inf` und `NaN`. `Inf` und `-Inf` stehen für Unendlichkeit und negative Unendlichkeit, und `NaN` steht für \"not a number\" und wird manchmal als Platzhalter für fehlende oder fehlerhafte numerische Werte verwendet.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ntype(float(\"Inf\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\nfloat\n```\n:::\n:::\n\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ntype(float(\"NaN\"))\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```\nfloat\n```\n:::\n:::\n\n\nAnmerkung: Python enthält einen dritten, seltenen numerischen Datentyp \"complex\", der zur Speicherung von komplexen Zahlen verwendet wird.\n\n## Booleans\n\nBooleans (\"bools\") sind Wahr/Falsch-Werte, die aus logischen Aussagen resultieren ([siehe Wiki](https://www.wikiwand.com/de/Boolean)). In Python beginnen booleans mit einem Großbuchstaben, sodass `True` und `False` als bools erkannt werden, \"true\" und \"false\" jedoch nicht. Ein Beispiel für booleans wurde bereits gesehen, als die Funktion isinstance() oben verwendet wurde.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ntype(True)\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```\nbool\n```\n:::\n:::\n\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nisinstance(False, bool)  # Überprüfung, ob False vom Typ bool ist\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\nTrue\n```\n:::\n:::\n\n\nBoolesche Werte können mit logischen Ausdrücken erzeugt werden. Python unterstützt alle standardmäßigen logischen Operatoren, die man erwarten würde:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n20 > 10 # > für größer als\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n20 < 5 # < für kleiner als\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```\nFalse\n```\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n20 >= 20 # >= und <= für größer oder gleich und kleiner oder gleich\n```\n\n::: {.cell-output .cell-output-display execution_count=46}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n10 == 10 # Verwendung von == (zwei aufeinanderfolgende Gleichheitszeichen), um auf Gleichheit zu überprüfen\n```\n\n::: {.cell-output .cell-output-display execution_count=47}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n40 == 40.0  # Äquivalente ints und floats gelten als gleich\n```\n\n::: {.cell-output .cell-output-display execution_count=48}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n1 != 2 # != um auf Ungleichheit zu überprüfen; \"nicht gleich\"\n```\n\n::: {.cell-output .cell-output-display execution_count=49}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nnot False # Das Schlüsselwort \"not\" für die Negation verwenden\n```\n\n::: {.cell-output .cell-output-display execution_count=50}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n(2 > 1) and (10 > 11) # \"and\" für logisches Und verwenden\n```\n\n::: {.cell-output .cell-output-display execution_count=51}\n```\nFalse\n```\n:::\n:::\n\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n(2 > 1) or (10 > 11) # \"or\" für logisches Oder verwenden\n```\n\n::: {.cell-output .cell-output-display execution_count=52}\n```\nTrue\n```\n:::\n:::\n\n\nÄhnlich wie bei mathematischen Ausdrücken haben logische Ausdrücke eine festgelegte Reihenfolge der Operationen. In einer logischen Aussage werden Vergleiche wie `>`, `<` und `==` zuerst ausgeführt, gefolgt von `not`, dann `and` und schließlich `or` ([siehe Details](https://docs.python.org/3/reference/expressions.html#operator-precedence)).\n\nKlammern werden verwendet, um die gewünschte Reihenfolge der Operationen zu erzwingen.\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\n2 > 1 or 10 < 8 and not True\n```\n\n::: {.cell-output .cell-output-display execution_count=53}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\n((2 > 1) or (10 < 8)) and (not True)\n```\n\n::: {.cell-output .cell-output-display execution_count=54}\n```\nFalse\n```\n:::\n:::\n\n\nZahlen können mit der Funktion `bool()` in boolesche Werte umgewandelt werden. Alle Zahlen außer 0 werden zu True konvertiert:\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nbool(1)\n```\n\n::: {.cell-output .cell-output-display execution_count=55}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nbool(0)\n```\n\n::: {.cell-output .cell-output-display execution_count=56}\n```\nFalse\n```\n:::\n:::\n\n\n## Strings\n\nTextdaten in Python werden als String oder `str` bezeichnet. Um einen String zu erstellen, umgibt man den Text mit einfachen oder doppelten Anführungszeichen:\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\ntype(\"cat\")\n```\n\n::: {.cell-output .cell-output-display execution_count=57}\n```\nstr\n```\n:::\n:::\n\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\ntype('1')\n```\n\n::: {.cell-output .cell-output-display execution_count=58}\n```\nstr\n```\n:::\n:::\n\n\nZwei Anführungszeichen direkt nebeneinander (wie `''` oder `\"\"`) ohne etwas dazwischen werden als der leere String bezeichnet. Der leere String stellt oft einen fehlenden Textwert dar.\n\nWährend numerische Daten und logische Daten im Allgemeinen gut handhabbar sind, können Textdaten sehr unordentlich und schwer zu bearbeiten sein. Das Säubern von Textdaten ist oft einer der mühsamsten Schritte bei der Vorbereitung von echten Datensätzen für die Analyse. In zukünftigen Lektionen wird erneut auf Strings und Funktionen eingegangen, um beim Säubern von Textdaten zu helfen.\n\n## None\n\nIn Python stellt `None` einen speziellen Datentyp dar, der häufig verwendet wird, um einen fehlenden Wert zu repräsentieren. Beispielsweise wird, wenn eine Funktion definiert wird, die nichts zurückgibt (keinen Ergebniswert liefert), standardmäßig `None` zurückgegeben.\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\ntype(None)\n```\n\n::: {.cell-output .cell-output-display execution_count=59}\n```\nNoneType\n```\n:::\n:::\n\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\n# Definieren einer Funktion, die den Eingabewert mittels 'print()' anzeigt, jedoch keinen Wert zurückgibt:\n\ndef my_function(x):\n    print(x)\n    \nmy_function(\"hello\") == None  # The output of my_function equals None\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=60}\n```\nTrue\n```\n:::\n:::\n\n\n",
    "supporting": [
      "02 kapitel_files"
    ],
    "filters": [],
    "includes": {}
  }
}