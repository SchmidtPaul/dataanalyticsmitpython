{
  "hash": "2a484bc414851765f48208b08e239352",
  "result": {
    "markdown": "---\ntitle: Mathematische Operatoren & Funktionen\n---\n\nPython ermöglicht alle grundlegenden mathematischen Berechnungen, die auch auf einem Taschenrechner durchgeführt werden können, mit einer Syntax, die einem z.B. durch Microsoft Excel zumindest teilweise geläufig ist.\n\n# Symbolische Operatoren\n\nDie Operatoren für Addition, Subtraktion, Multiplikation und Division sind erwartungsgemäß:\n\n::: {layout-ncol=\"4\"}\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n10 + 3\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n13\n```\n:::\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n10 - 3\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n7\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n10 * 3\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n30\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n10 / 3\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n3.3333333333333335\n```\n:::\n:::\n\n\n:::\n\nFür die Potenzierung wird `**` genutzt:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n10 ** 3\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n1000\n```\n:::\n:::\n\n\nMathematische Ausdrücke in Python folgen der normalen arithmetischen Reihenfolge der Operationen, also\n\n1.  `**`\n2.  `*` und `/`\n3.  `+` und `-`\n\nEs können aber Klammern eingesetzt werden um eine andere Reihenfolge zu erreichen:\n\n::: {layout-ncol=\"2\"}\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n1 + 2 * 3 ** 2\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n19\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n((1 + 2) * 3) ** 2\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n81\n```\n:::\n:::\n\n\n:::\n\nDer Vollständigkeit halber soll erwähnt sein, dass es weitere, nicht so gängige Operatoren gibt. Beispielsweise wird mit `//` erst dividiert und dann der Quotient auf die nächste ganze Zahl abgerundet, sodass `10 // 3` = 3. Mit dem Modulus-Operator `%` hingegen wird der Rest, der bei der Division zweier Zahlen entsteht, zurückgegeben, sodass `10 % 4` = 2.\n\n# Mathematische Funktionen\n\nSelbstverständlich ist es auch möglich z.B. den Logarithmus einer Zahl zu berechnet. Allerdings gibt es dafür kein Symbol, sondern eine Funktion. Diese und andere Funktionen sind im Standardmodul `math` enthalten, sodass wir dieses zunächst laden müssen.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nimport math # Das math-Modul laden\n```\n:::\n\n\nStandardmäßig wird der natürliche Logarithmus von 100 berechnet, wobei die Basis des Logarithmus die [Euler'sche Zahl](https://www.wikiwand.com/de/Eulersche_Zahl) $e$ (≈ 2,718) ist. Es kann aber auch der Logarithmus zu einer beliebigen Basis berechnet werden, solange die als zweites Argument in der Funktion angegeben wird:\n\n::: {layout-ncol=\"2\"}\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# Logarithmus zur Basis e\nmath.log(100)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n4.605170185988092\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# Logarithmus zur Basis 10\nmath.log(100, 10) \n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n2.0\n```\n:::\n:::\n\n\n:::\n\nAnalog kann auch die Exponentialfunktion ($e^x$) berechnet werden, wobei $e$ wieder die Euler'sche Zahl ist. Schließlich kann auch die Quadratwurzel $\\sqrt(x)$ gezogen werden:\n\n::: {layout-ncol=\"2\"}\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nmath.exp(10) \n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n22026.465794806718\n```\n:::\n:::\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nmath.sqrt(9)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n3.0\n```\n:::\n:::\n\n\n:::\n\n# Zahlen runden\n\nIn Basis-Python gibt es eine `round()` Funktion, mit der Zahlen standardmäßig auf die nächste ganze Zahl gerundet werden können. Mit dem zweiten Argument der Funktion kann auch auf eine bestimmte Dezimalstelle gerundet werden:\n\n::: {layout-ncol=\"3\"}\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# keine Nachkommastelle\nround(123.456) \n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n123\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# zwei Nachkommastellen\nround(123.456, 2) \n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n123.46\n```\n:::\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# auf die 10er-Stelle runden\nround(123.456, -1)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n120.0\n```\n:::\n:::\n\n\n:::\n\nEs können auch `math.ceil` und `math.floor` verwendet werden, um auf- oder abzurunden.\n\n::: {layout-ncol=\"2\"}\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# Aufrunden\nmath.ceil(123.456)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n124\n```\n:::\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# Abrunden\nmath.floor(123.456)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n123\n```\n:::\n:::\n\n\n:::\n\n",
    "supporting": [
      "01 kapitel_files"
    ],
    "filters": [],
    "includes": {}
  }
}